import type { Message } from '@/types/assistant';

/**
 * Export conversation to Markdown format
 */
export function exportToMarkdown(
  messages: Message[],
  sessionId?: string,
  workspaceId?: string
): string {
  let markdown = `# AuditGuardX AI Conversation\n\n`;
  markdown += `**Date:** ${new Date().toLocaleString()}\n`;
  if (sessionId) markdown += `**Session ID:** ${sessionId}\n`;
  if (workspaceId) markdown += `**Workspace ID:** ${workspaceId}\n`;
  markdown += `\n---\n\n`;

  messages.forEach((message) => {
    const role = message.role === 'user' ? 'ðŸ‘¤ User' : 'ðŸ¤– Assistant';
    const time = new Date(message.timestamp).toLocaleTimeString();

    markdown += `## ${role} (${time})\n\n`;
    markdown += `${message.content}\n\n`;

    if (message.actions && message.actions.length > 0) {
      markdown += `**Actions:**\n`;
      message.actions.forEach((action) => {
        markdown += `- ${action.label || action.type}: ${action.target || 'N/A'}\n`;
      });
      markdown += `\n`;
    }

    if (message.sources && message.sources.length > 0) {
      markdown += `**Sources:**\n`;
      message.sources.forEach((source) => {
        markdown += `- ${source.name}${source.page ? ` (Page ${source.page})` : ''}${source.url ? ` - ${source.url}` : ''}\n`;
      });
      markdown += `\n`;
    }

    markdown += `---\n\n`;
  });

  markdown += `\n*Generated by AuditGuardX AI Assistant*\n`;
  return markdown;
}

/**
 * Export conversation to JSON format
 */
export function exportToJSON(
  messages: Message[],
  sessionId?: string,
  workspaceId?: string
): string {
  const exportData = {
    metadata: {
      exportDate: new Date().toISOString(),
      sessionId,
      workspaceId,
      messageCount: messages.length,
    },
    messages: messages.map((msg) => ({
      role: msg.role,
      content: msg.content,
      timestamp: msg.timestamp,
      actions: msg.actions || [],
      sources: msg.sources || [],
    })),
  };

  return JSON.stringify(exportData, null, 2);
}

/**
 * Download file to user's computer
 */
export function downloadFile(content: string, filename: string, mimeType: string) {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Export conversation in specified format
 */
export function exportConversation(
  messages: Message[],
  format: 'markdown' | 'json' = 'markdown',
  sessionId?: string,
  workspaceId?: string
) {
  const timestamp = new Date().toISOString().split('T')[0];

  let content: string;
  let filename: string;
  let mimeType: string;

  switch (format) {
    case 'markdown':
      content = exportToMarkdown(messages, sessionId, workspaceId);
      filename = `conversation-${sessionId || timestamp}.md`;
      mimeType = 'text/markdown';
      break;
    case 'json':
      content = exportToJSON(messages, sessionId, workspaceId);
      filename = `conversation-${sessionId || timestamp}.json`;
      mimeType = 'application/json';
      break;
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }

  downloadFile(content, filename, mimeType);
}

/**
 * Copy conversation to clipboard
 */
export async function copyConversationToClipboard(
  messages: Message[],
  sessionId?: string,
  workspaceId?: string
): Promise<void> {
  const markdown = exportToMarkdown(messages, sessionId, workspaceId);

  try {
    await navigator.clipboard.writeText(markdown);
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    throw error;
  }
}
